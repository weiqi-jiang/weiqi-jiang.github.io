---
layout: post
title: Computer Network
category: Resource
tags: computer network
description: 计算机网络基本知识，信息主要来源<计算机网络：自顶而下方法> 
---

## 基础概念：

### 存储转发机制（store-and-forward transmission）
交换机能够最开始向输出链路传输该分组的第一个比特之前，必须接受整个分组。也就是说交换机是以分组为单位进行传输的。
如果由**N条速率均为R的链路组成的路径(一条路劲)**，从源到目的地发送**一个分组**端到端的时延为N*（L/R）如果P个分组进行N条链路序列的时延，从目的地host的角度去想，接受到第一个分组的时候花了N个单位，后来每过一个单位接受一个分组，剩下的有P-1个分组，因为第一个已经接受到了，(N + P-1)*(L/R)
一般分组交换机会与多条链路相连，对于每一条链路，分组交换机有一个**输出缓存(output buffer)**存储准备发往那条链路的分组。如果到达的分组发现链路正在忙着传输其他分组，那么就需要在输出缓存中等待。如果达到的分组发现输出缓存已经全部充满，那么达到的分组和已经排队的分组中的一个会被丢弃，**造成丢包(packet lost)**

### 线路复用方式

**频分复用（Frequency division multiplexing,FDM)**

频域被划分为频段，每个频段具有自己的带宽(bandwidth)

**时分复用（Time division multiplexing,TDM）**

时间被分为若干帧，一个帧又被分为若干时隙

### **分组交换（packet switching）和电路交换（circuit switching）**

- 分组交换：通信双方以**分组**为单位、使用存储-转发机制实现数据交互的通信方式
- 分组交换不适合实时服务，因为end-to-end的时延是不可预测的
- 分组交换提供更好的带宽共享，更简单，更**有效**，成本低
- 分组交换更加有效的原因，假设用户的使用频率10%，假设一条链路使用电路交换，被分为10条电路，只能服务10个用户；假设使用分组交换，35个用户的情况下，并发处理11个用户之上的概率为0.04%。几乎不会有延迟。或者是某一个用户突发的使用大数据量，其他用户保持缄默，电路交换的效率太低。

**分组交换网络中的时延**
1. 节点处理时延（node processing delay）
2. 排队时延（queuing delay）
3. 传输时延（transmission delay）
4. 传播时延（propagation delay）
5. 以上相加就是节点总时延（total nodal delay）
**结点处理时延**：检查分组首部，决定出链路；检查差错，微秒或者更低
**排队时延**：毫秒到微秒级别
**传输时延**：分组长度/链路传输速率；将所有分组中的bit推向链路所需的时间
**传播时延**：从链路的起点到终点所需的时间，毫秒级别
比特到达队列的平均速率假设为La，a是一秒内到达队列的分组数，L为分组的平均长度；R为路由器的传输速率R； **La/R 表征流量强度；不能大于1**

### 因特网的协议栈（protocol stack)

1. 应用层
2. 运输层
3. 网络层
4. 链路层
5. 物理层

**应用层**
- 应用层是网络应用程序及它们的应用层协议存留的地方。应用层包括的协议有**HTTP、SMTP、FTP、DNS**等。
- 应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，位于应用层的信息分组称为**报文（message）**。

**运输层**
- 因特网的运输层在应用程序端点之间传送应用层报文。
- 因特网中的两个运输协议：**TCP（Transmission Control Protocol）、UDP(User Datagram Protocol)**。
- TCP协议向它的应用程序提供了**面向连接的服务**，包括应用层报文向目的地的**确保传递**和**流量控制**。TCP将长报文划分为短报文，并提供**拥塞控制机制**，因此当网络拥塞时，源抑制其传输速率。
- UDP协议向它的应用程序提供**无连接服务**。UDP协议是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。
  运输层分组称为**报文段（segment）**

**网络层**
- 因特网的网络层负责将称为**数据报（datagram）**的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址。
- 因特网的网络层包括著名的IP协议，该协议定义了在数据包中的各个字段以及端系统和路由器如何作用于这些字段, 仅有一个IP协议，**所有具有网络层的因特网组建必须运行IP协议**。
- 也包括一些决定路由的路由选择协议，使得数据报根据该路由从源传输到目的地

**链路层**
- 因特网的网络层通过源和目的地之间的一系列路由器路由数据报。
- 在每个结点，网络层将数据包下传给链路层，链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层
- 由链路层提供的服务取决于应用于该链路的特定链路层协议。
- 链路层的例子包括**以太网、WiFi和电缆接入网的DOCSIS协议**。**链路层分组称为帧（frame）**。

**物理层**
- 物理层的任务是将帧中的一个一个bit从一个结点移动到下一个结点。
- 物理层的协议与链路相关，并且进一步与该链路（例如双绞铜线、单模光纤）的实际传输媒体相关。

**七层OSI参考模型**
- 七层OSI（开放系统互连）参考模型自顶向下依次为：**应用层，表示层，会话层，运输层，网络层， 链路层和物理层**。对比之下可以发现，OSI模型与因特网协议栈相近，只不过附加了两个层，即**表示层和会话层**。其它五层的功能与因特网协议栈大致相同。
- 表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩和数据加密（它们是自解释的），以及数据描述。
- 会话层提供了数据交换定界和同步功能，包括了建立检查点和恢复方案的方法。
- 因特网协议栈缺少的两层服务由应用程序开发者处理。应用程序开发者决定一个服务是否是重要的，如果该服务重要，应用程序开发者就应该在应用程序中构建该功能。

**不同层运行的协议：**

![img](/assets/img/resource/computer-network/protocol.png)

**不同层使用的互联设备**

![img](https://uploadfiles.nowcoder.com/images/20170606/1158385_1496709959449_35352929445D5B453EA3677F7BE8336D)

## 应用层
### 应用层两个主流体系结构

1. Client-server architecture**, 有一个永远打开的主机称为服务器
2. P2P architecture** 应用程序在间接连接的主机对之间使用直接通信，这些主机对被称为***对等方。***通信不必通过专门的服务器，体系结构被称为对等方到对等方的

**P2P体系结构面临三个挑战：**

1. ISP 友好
2. 安全性
3. 激励

### 进程通信
不管在client-server 还是p2p结构中，发起通信的进程都被标记为客户，会话开始时等待联系的进程是服务器
进程通过一个**套接字（socket）**接口向网络发送和接受报文, **socket 是同一台主机内应用层于运输层之间的接口，** 因为socket 是可编程的，也被称为**应用程序和网络之间的API**

### 进程寻址
接收进程需要定义两个信息
1. 主机的地址（IP地址）
2. 目标主机中的接受进程的标识符，**端口号**用于这个目的，已经给流行的应用分配了特有的端口号

**常见默认端口号：**
- FTP 21
- SSH 22
- TELNET 23
- SMTP 25
- TFTP 69
- HTTP 80
- SNMP 163
- HTTPS 443
- TOMCAT 8080

### 应用层协议(application- layer protocol)

应用层协议定义了：
1. 交换的报文类型，请求报文还是响应报文
2. 各种报文的语法
3. 字段的语义
4. 一个进程何时以及如何发送报文，对报文进行响应的规则

有些应用层协议是公开的例如HTTP，有些是专用的

**HTTP（HyperText Transfer Protocol）基于TCP**
- 由两个程序实现：一个客户程序一个服务器程序
- 使用**TCP作为它的支撑运输协议**
- 发送端使用套接口发送HTTP请求报文，接受HTTP响应报文，接收端使用套接口接受请求报文，发送响应报文
- HTTP并不存储关于用户的任何信息，所以说**HTTP是无状态协议（stateless protocol）**

**HTTP 报文格式**
请求报文
e.g.

> *GET \*/somedir/page.html\* HTTP/1.1* 
>
> *Host*: *www.someschool.edu*
>
> *Connection*: *close*
>
> *User-agent*: *Mozilla/5.0*
>
> *Accept-language*: *fr*

第一行请求行，剩余的叫做首部行； 三个字段： 方法字段、URL字段、HTTP版本字段；方法字段包含**GET,POST,HEAD,PUT,DELETE**

首部行
- Host指明了对象所在的主机。（这是Web代理高速缓存所要求的）；
- Connection：close表示浏览器要求服务器在发送完被请求的对象后就关闭该链接，keep-alive则是使用持续连接；
- User-agent指明向服务器发送请求的浏览器的类型；
- Accept-language表示用户想得到的对象的语言版本，如果服务器不存在该版本，则发送它的默认版本；

请求报文的通用格式：

![20180401175015211](/assets/img/resource/computer-network/request-post-application.png)

其中entity body 在get方法中为空，用表单生成的请求使用POST方法，就要用到实体主体，包含一些必要的信息，例如搜索引擎的关键词；

但是用表单生成的请求不是必需使用POST方法，可以在URL中包含输入的数据，仍然使用GET方法达到同样的效果

HEAD方法和GET方法类似，服务器接收到HEAD方法的请求时，用一个HTTP报文进行响应，但是不返回请求对象，用于调试。

PUT和DELETE允许用户上传和删除web服务器上的指定路径

**HTTP响应报文**

e.g.

> HTTP/1.1 200 OK
> Connection: close
> Date: Tue, 09 Aug 2011 15:44:04 GMT
> Server: Apache/2.2.3 (CentOS)
> Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
> Content-Length: 6821
> Content-Type: text/html
>
> (data data data data data ...)

- 其中，第一行为初始状态行，接下来的有6个首部行，然后是实体体（entity body）。实体体部分是报文的主要部分，即它包含了所请求的对象本身。
- 状态行有3个字段：协议版本字段、状态码和相应状态信息。
- Connection: close 发送完报文后将关闭该TCP连接
- Date 服务器从它的文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间
- Server 服务器信息
- Last-Modified 服务器认定的资源做出修改的日期及时间
- Content-Length 被发送对象的字节数
- Content-Type 例子中指出实体体中的对象是HTML文本

响应报文的通用格式

![20180401184007563](/assets/img/resource/computer-network/response-post-application.jpg)

**常用的状态码：**

- 200 OK，请求成功； 2xx 成功
- 1xx 通知
- 301 Moved Permanently 请求的对象已经被永久转移了，新的URL定义在响应报文的location，客户软件会在首部行中自动获取 新的URL
- 302 Moved temporarily
- 303 see other
- 307 temporarily redirect
- 400 Bad Request 一个通用差错代码，指示该请求不能被服务器理解
- 404 Not Found 被请求的文档不在服务器上
- 505 HTTP Version Not Support不支持HTTP协议版本
- 4xx 客户端错误，5xx服务器端错误

### Cookie

HTTP 服务器是stateless的，但是web站点通常是希望识别用户的，于是HTTP使用了cookie

cookie技术的四个组件

1. HTTP响应报文中cookie首部行
2. HTTP请求报文中cookie首部行
3. 用户客户端保留一个cookie文件
4. 位于web站点的一个后端数据库

### Web Cache,代理服务器（proxy server）

- web缓冲有自己的磁盘存储空间，保存最近请求的对象的副本
- 代理服务器相当于在初始服务器和客户之间做一个“代理”，如果代理服务器中没有请求的内容，则向初始服务器请求，并在接受时保存一个副本，并响应给客户

好处/坏处：

1. 大大减少对客户请求的响应时间（客户与代理之间的带宽大于客户和初始服务器之间的带宽）
2. 大大减少一个结构的接入链路到因特网的通信量，不必着急增加带宽，减少费用
3. 存在缓冲服务器上的版本可能是陈旧的，可以通过**条件GET方法**确保版本最新

**条件GET方法**

1. 在客户第一次像初始服务器请求报文，报文经过代理服务器，代理服务器向初始服务器发送请求报文
2. 初始服务器向缓冲服务器发送带有请求的对象的响应报文
3. 缓冲服务器将对象转发给客户，同时自己保留一份副本，其中一个首部行包含了对象最后修改日期
4. 一段时间之后，用户像初始服务器请求同一个对象
5. 缓冲服务器向初始服务器发送一条GET请求报文，其中一个首部行If-Modified-Since, 值为上一次缓冲对象的最后修改日期。
6. 如果服务器在该日期之后修改过该对象就重新发送，如果没有，发送一个实体主体为空的响应报文 

![WeChat Screenshot_20190704184330](/assets/img/resource/computer-network/proxy-server.png)

### FTP 文件传输协议（基于TCP）

用户通过一个FTP用户代理与FTP交互（PUTTY，XSHELL）该用户首先提供远程主机的主机名，使本地主机的FTP客户进程创建一个到远程主机FTP服务器进程的**TCP连接**。该用户提供用户标识和口令，作为FTP命令的一部分在TCP连接上传送。一旦通过授权，就可以从远程服务器处传送或者接受文件

FTP协议首先建立一个客户到服务器的*控制TCP连接*，**当接收到文件传输命令时，建立一条\*新的data connection\*，完成数据传输之后关闭该connection，如果需要另一个数据传输需求，新建一条data connection.** 但是**控制TCP连接是贯穿整个会话的**

也就是有两个TCP链接，一个control connection 一个data connection

**FTP和HTTP的异同**

- HTTP和FTP 都是文件传输协议
- FTP使用两个并行的TCP连接，一个是control connection 一个是data connnection； 控制连接主要传输控制信息，如用户名，密码，get，put命令等，data connnection负责实际发送一个文件
- 由于FTP使用另一个TCP连接专门负责控制信息，所以FTP的控制信息是out-of-band传送的；HTTP 是带内传送控制信息的
- FTP 需要维护用户的状态是有state的，因为需要知道用户当前的浏览目录等信息，所有限制了同时维持的会话数，**HTTP是stateless的，有更大的同时会话数**

### DNS 因特网的目录服务（Domain Name System）

**基于UDP**

简单来说就是主机名到IP地址转换的目录服务,组成成分：

1. 一个由**分层的DNS服务器实现的分布式数据库**
2. 一个使得主机能够查询分布式数据库的协议

DNS协议运行在**UDP**之上，使用**53号端口**

一个使用例子：

![WeChat Screenshot_20190704193523](/assets/img/resource/computer-network/DNS.png)

相当于在正常HTTP请求之前加上了一段域名到IP的转换，**引入了额外的时延**

DNS同时提供以下服务：

- 主机别名
- 邮件服务器别名
- **负载分配**；由于同一个站点有多台服务器，有多个不同的IP地址；一个规范主机名和一个IP地址集合相联系；DNS负责在冗余的web服务器之间循环分配负载

**DNS服务器**

三种类型的DNS服务器

1. 根DNS服务器
2. Top-Level Domain ,TLD
3. 权威DNS服务器

![DNS-SERVER](/assets/img/resource/computer-network/DNS-SERVER.png)

![DNS-SERVER](/assets/img/resource/computer-network/DNS-SERVER1.png)

![DNS-SERVER](/assets/img/resource/computer-network/DNS-SERVER2.png)

DNS大量使用**DNS缓存**

一个请求链中，当某DNS服务器接收一个DNS回答时，她能将该回答中的信息缓存在本地存储器中，由于主机名和IP地址间的映射不是永久的，DNS服务器在一段时间后将丢弃缓存的信息。

**DNS 记录和报文**

资源记录是一个包含了下列字段的4元祖

（Name, Value, Type, TTL）

- TTL 该记录的生存时间，过了该时间，该记录从缓存中删除
- Type = A, Name 是主机名，value是IP地址
- Type = NS, Name 是域名， Value是个知道如何获取该域中主机IP地址的权威DNS服务器的主机名
- Type = CNAME value 是别名为Name的主机对应的规范主机名，提供一个主机别名对应的规范主机名
- Type = MX Value 是个别名为Name的邮箱服务器的规范主机名



### P2P应用

参见计算机网络：自顶而下方法97-102

分布式散列表

分布式的，P2P版本的键值对数据库，每个对等方保留的键值对只占总体的一个小子集

每个对等方用一个特别的键来查询该分布式数据库，分布式数据库定位拥有该相应键值对的对等方，向查询方返回键值对，任何对等方也将允许在数据库中插入新键值对



### UDP /TCP编程实现

github：https://github.com/JIANGWQ2017/Computer-Networking

![TCP](/assets/img/resource/computer-network/TCP.png)

![tcp2](/assets/img/resource/computer-network/tcp2.png)



## 运输层

运输层协议为运行在不同的主机上的应用进程之间提供**逻辑通信（logic communication），**并不是物理通信

运输层协议不止一个，对协议主要考察的点在于四个点

1. **可靠数据运输**，确保分组能从发送端到达接收端
2. **吞吐量**，提供确保的可用吞吐量，对带宽有要求的程度称为带宽敏感应用(bandwidth-sensitive application)
3. **定时**，确保比特能够在特定时延下到达对方套接字
4. **安全性**，运输过程中确保加密

**运输层协议实现在端系统中**，而不是路由器中**，网络层是实现了\*主机\*之间的逻辑通信**，而运输层是运行在不同的主机上的应用进程之间提供逻辑通信；区别在于网络层负责信息从主机到另一个主机，运输层负责信息到达主机之后到进程的分发，因为运输层只实现在端系统中。把主机间交付扩展到进程间交付被称为**运输层的多路复用（Transport-layer multiplexing）和多路分解（demultiplexing）**

![WeChat Screenshot_20190705204934](/assets/img/resource/computer-network/WeChat-Screenshot_20190705204934.png)

下面详细讲解上图就可以完全了解多路分解和多路复用的概念，以及运输层和网络层的异同；

首先应用层一个或者若干个应用通过各自的套接字（socket遵守TCP,UDP之一的协议）把不同的***数据块***推给运输层，运输层为每个数据块封装上首部信息（包含**源端口号**和**目的端口号**），生成***报文段***。将报文段推送给网络层（遵守IP协议），网络层进行自己的封装，然后进行主机级别的逻辑通信，这个过程称为***多路复用***（班长（运输层）收集同学们（应用层）的信，一并发给邮局（网络层）），网络层以下层数完成了主机到主机的逻辑通信，在接受端，网络层把接受到数据拆封成报文段，把报文段推送给运输层，运输层检查报文段中的字段，把数据交付到正确的套接字，这个工作称为***多路分解（demultiplexing）***，如果接收端想传送一个数据回发送端，只需提取接受到的源端口号，作为目的端口号，发送回去就行。而且

**UDP协议下基本情况就如上**，**UDP套接字是用一个二元组完全标识的（目标IP地址，目标端口号），***如果UDP报文段有不同的源IP地址或者是端口号，但是有相同的目的地址和目的端口号，那么会使用相同的套接字把数据定位到相同的进程*。是但是在有连接的多路复用和多路分解要复杂一些，也就是TCP协议下的通信，python实现UDP协议通信时，创建client套接字的时候，系统自动分配一个端口号，往往这个端口号在client端是用不到的，当然也可以自己制定bind特定端口号。服务器端可以拿到这个client端的端口号，如果想回传文件的话就用这个端口号就行，client端不需要知道这个端口号具体是多少。

**TCP多路分解复用:**

**TCP套接字用四元祖标识（源IP地址，源端口号，目的IP地址，目的端口号）， 和UDP不同的是，两个不同源地址的报文段，会被定向到两个不同的套接字**

为什么UDP只需要两个元祖，而TCP需要四个元祖才能完全描述：

- TCP目的应用可能同时和不同的源应用建立TCP通信，所以要分别建立不同的TCP连接，用四个元祖描述
- UDP不需要建立连接，是非持续连接，不同的源应用，使用同一个套接字连接目的应用就行，如果需要重复连接，就需要源应用再发起一次通信。

### 因特网提供的运输服务

因特网为应用提供两个运输层协议**，TCP,UDP；\*两者都没有提供任何加密机制\***；如果使用TCP协议，进程传进套接字的数据和经网络到达目的地进程的数据相同，如果发送进程传送明文数据，就可能被嗅探或发现。TCP的改进型- SSL(secure Socket Layer)安全套接字层

**1 TCP**

服务模型包含

- **面向连接服务**；数据报文开始流动时，TCP让客户和服务器互相交换运输层控制信息，提示客户和服务器，为大量分组的到来做好准备，***握手***之后，一个TCP connection就在两个进程套接字之间建立了。连接是***全双工***的，双方可以同时进行报文收发。在报文传输结束后，必须拆除该连接
- **可靠数据传输**；通信进程依靠TCP进行无差错，按适当顺序交付所有发送的数据，没有字节丢失和冗余
- 拥塞控制机制；在网络出现拥塞时，抑制发送进程
- **提供可靠数据传输，安全性（通过SSL实现），并没有提供吞吐量和定时服务**

**2 UDP**

- 不提供不必要服务的轻量级协议
- 无连接的，不需要握手过程
- 提供不可靠数据传输服务
- 接受进程的报文可能是乱序到达的
- 没有拥塞控制机制

网络层中的**IP协议是不可靠服务，不确保数据报的运输，不确保数据报的按序运输，不保证数据报中数据的完整性，**运输层的**TCP协议提供可靠数据传输**，把主机间的不可靠ip数据传输转换成进程间的可靠数据传输，如何实现？：

1. **重传和确认**：接收方收到报文就会确认，发送方一段时间没有收到确认就重传
2. **数据校验**
3. **数据合理分片和排序**；UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报； TCP会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。
4. **流量控制**：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，**接收发送效率匹配**，防止包丢失。
5. **拥塞控制**，降低速率，降低丢包率

### 无连接运输UDP：

UDP是一个轻量级的协议，对于IP，除了增加复用/分解功能，和少量差错检测外，基本不增加别的东西。所以选择UDP，则开发者基本都只和IP打交道。使用UDP发送报文之间，接收方和发送方是没有握手的，所以称为无连接运输，发送方发送报文之后，等待接收方响应，接受方这时有可能响应失败或者其他情况，使得发送方无响应。

![WeChat Screenshot_20190705232028](/assets/img/resource/computer-network/WeChat-Screenshot_20190705232028.png)

UDP的报文段结构

![WeChat Screenshot_20190705233755](/assets/img/resource/computer-network/udp.png)

UDP首部只有4个字段，每个字段两个字节；长度指明UDP报文字节数（包含首部）

### **面向连接的运输 TCP**

TCP是面向连接的（connection-oriented）,**TCP 协议只在运输层中实现，网络层中不维持TCP连接**。**TCP连接状态完全保留在端系统中**，中间路由器看的是数据报，而不是连接。TCP连接是**全双工，并且点对点的**

发送端和接收端首先通过三次握手， 建立TCP连接，前两次握手不承载“有效载荷”，第三次握手承载“有效载荷”，TCP从套接字中接收到应用层发来的数据，引导这些数据进入发送缓存（send buffer），然后TCP时不时的从缓存中提取数据，TCP从缓存中提取数据放入报文段的大小受最大报文段长度的限制（Maximum,Segment Size,指的是报文段中应用层数据的最大长度，不包含首部段）TCP为每个客户数据配上一个TCP首部，从而形成多个TCP报文段（TCP segment），

![WeChat Screenshot_20190706151447](/assets/img/resource/computer-network/transport-tcp.png)

![WeChat Screenshot_20190706151547](/assets/img/resource/computer-network/transport-tcp2.png)

TCP报文段的首部字段详细解释，不需要太了解。大概看一下就好。

TCP协议在IP不可靠的经历而为的服务上，创建了一种可靠数据传输服务，TCP的可靠数据传输服务是保证一个进程从接收缓存中提取的数据流是无损坏，无间隔，非冗余和按序的数据流

**Reference**

[计算机网络：这是一份全面 & 详细 的TCP协议攻略](https://www.jianshu.com/p/65605622234b)

### 三次握手

**第一步**： client的TCP首先像服务器的TCP发送一个特殊的TCP报文段，报文段中不包含应用层数据，报文段首部中的一个标志位SYN比特会置位1，故该特殊报文段被称为SYN报文段，另外client会随机选择一个初始序号，并放置于该起始的TCP SYN报文段的序号字段中。

**第二步**：SYN报文段到达服务器主机，该服务器会从该数据包中提取出SYN报文段，为该TCP连接分配变量和缓存，并向client端传送回允许连接的报文段。该报文段也不包含应用层数据，不过SYN置位1，该TCP报文段确认号字段被设为初始序号+1，最后服务器选择自己的初始序号server_isn. 将其放置入序号字段上。该回复报文段偶尔被称为SYNACK报文段

**第三步**：在收到SYNACK报文段后，client端也要为该连接分配缓存和资源。客户主机向服务器发送另外一个报文段，对服务器允许连接的报文进行确认。把server_isn+1置入确认号字段，此时连接已经生成，所以SYN置位0. 此时负载中可以携带客户到服务器的数据

三次握手如果有一次没有成功收到报文，都会重发

**为什么需要三次握手，第三次是握手是为了什么？**

**防止服务器端因为接收到了早已失效的连接请求报文**，从而一直等待客户端请求，而且服务器端一直保留该TCP连接的缓存和资源，可是服务器端早已经觉得该TCP连接过期，不会发送数据，最终导致**形成死锁，浪费资源。**

![img](/assets/img/resource/computer-network/three-handshake.jpg)

**connect(),listen(),accept() 函数**

**conect**函数的作用是用于主动发起连接服务器，通过三次握手完成连接，这个连接是由内核完成，这个函数的作用是通知内核去完成连接成功返回0，失败返回-1

**listen**函数是被动的，将socket变成被动监听嵌套字，listen函数不会阻塞，告诉内核一些信息之后，listen函数就结束了

**accept**函数

accept()系统调用主要用在基于连接的套接字类型，比如SOCK_STREAM和SOCK_SEQPACKET。它**提取出所监听套接字的等待连接队列中第一个连接请求**，**创建一个新的套接字，并返回指向该套接字的文件描述符**。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。**返回一个新的connection 套接字**

备注：新建立的套接字准备发送send()和接收数据recv()。

![WeChat Screenshot_20190706161308](/assets/img/resource/computer-network/tcp-handshake.png)

### **四次挥手-TCP连接的终止**

![944365-91b079843a9e8235](/assets/img/resource/computer-network/4handshake.png)

![WeChat Screenshot_20190706162546](/assets/img/resource/computer-network/4handshake2.png)

**为什么需要四次挥手？**

为了确保通信双方都能通知对方需释放断开连接，因为连接是全双工的，所有释放的时候也要确保双方都无法发送和接受信息

**为什么最后客户端要等待2MSL时间才关闭连接？**

**MSL**: 最长报文段寿命（Maximum Segment Lifetime）,要确保客户端发送的最后一个连接释放报文能到达服务器，从而使得服务器能正常释放连接。如果最后一个连接释放报文丢失，服务器超时接收就会重发释放报文，客户端在2MSL时间内就会收到一个服务器重发来的请求，重置2MSL时间。

第二个原因是等待的2MSL时间内，本次连接所产生的所有报文段都会从网络中小时，从而下一个新连接不会出现早已经实现的连接请求报文。

### **非持续连接时延/持续连接时延**

每个请求和响应是通过单独的TCP连接发送/还是通过相同的TCP连接发送，分为非持续连接和持续连接。

发起一个TCP连接的**“三次握手”**

- 客户向服务器发送一个小TCP报文段
- 服务器用一个小TCP报文段做出确认和响应
- 客户返回确认并向该TCP连接连续发送一个HTTP请求报文

服务器接收到请求报文，在该TCP连接上发送HTML文件

![WeChat Screenshot_20190704161336](/assets/img/resource/computer-network/tcp-timedelay.png)

粗略的说总得响应时间就是两个RTT（round-trip time），一个RTT用来创建TCP 连接，一个RTT用来传送数据，加上传送HTML文件的时间



# 网络层

网络层的作用很简单，即将分组从一台发送主机移动到一台接收主机。需要两种重要的网络层功能：

- **转发**，当一个分组到达路由器的一条输入链路中，路由器必须将该分组移动到适当的输出链路。
- **路由选择**；当分组从发送方到接受方时，网络层必须决定采用的路由或者路径，计算路径的算法称为路由选择算法（routing algorithm）
- 某些计算机网络中，还有**连接建立**的的功能

每一台路由器具有一个**转发表（forwarding table），**路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在该路由器的转发表中索引查询

因特网网络层提供**单一**的服务，称为***尽力而为服务（best-effort service）***,其实等同于无服务，没有丢包保证，没有有序保证，没有定时保证，没有拥塞控制，没有带宽保证

### 网际协议（IP protocol）

因特网的网络层有三个主要组件

1. IP协议
2. 路由选择部分，路由选择协议
3. 报告数据报中的差错和对某些网络层信息请求进行响应；即因特网控制报文协议（ICMP）

网络层分组被称为*数据报，*IPv4数据报格式如下

![WeChat Screenshot_20190706203328](/assets/img/resource/computer-network/ipv4-post.png)

**IP数据报分片**

由于并不是所有的链路层协议都可以承载相同长度的网络层分组，有的协议只能承载小分组，一个链路层能承载的最大数据量叫做最大传送单元（Maximum Transmission Unit MTU）, 假设某条链路收到一个IP数据报，然后检查转发表确定出链路，发现出链路的MTU比ip数据报的长度要小，这个时候就需要把数据报分片，较小的数据报叫做**fragment（片）**

在接受端主机的运输层之前，数据片需要组装，为了坚持网络内保持简单的原则，**IPv4的数据报的重新组装放在端系统中，而不是放在网络路由器上**。

在目的端系统中，数据报在IP层完全重构才会被传送给运输层，如果有任意一个片没有到达，不完整的数据报会被遗弃，如果运输层使用TCP，则会让源重新发送防止丢包。

**IPv4编址**

每个IP地址长度为32比特（4个字节）共有2^32次方可能，大约40亿种，一般按照**点分十进制记法，**每个字节用它的十进制表示，字节间用点分开。**IP地址技术上是与一个interface相关联，而不是与包含该接口的主机或路由器相关联的**。

A类地址：**1**.0.0.0 ~ 127.255.255.255
B类地址：**128**.0.0.0 ~ 191.255.255.255
C类地址：**192**.0.0.0 ~ 223.255.255.255
D类地址：**224**.0.0.0 ~ 239.255.255.255
E类地址：**240**.0.0.0 ~ 247.255.255.255

![WeChat Screenshot_20190706213123](/assets/img/resource/computer-network/ip-addressing.png)

互联这三个主机接口和1个路由器接口的网络形成一个**子网（sub-net）**IP编址为每个子网分配一个地址：223.1.1.0/24 有时称为**子网掩码，** /24用于指示前24比特定义了子网地址,数字可以不为24.

因特网的地址分配原则称为**无类别域间路由选择（Classless InterDomain Routing, CIDR）**形如a.b.c.d/x ，表示前x位用来构成IP地址的网络部分，称为该地址的prefix，外网IP 只考虑前面的x位。之前是采用固定的前8，16,24位作为外网地址，后来发现问题了，就采用classless的方式，外网位数可以随意定义。IP广播地址255.255.255.255 专门同时向网络中发送数据报的地址。

首先从注册机构处获取一块地址，然后使用**动态主机配置协议（Dynamic Host Configuration Protocol, DHCP）**DHCP允许主机自动获取一个IP地址，DHCP具有能将主机连接进一个网络的自动能力，故被称为**即插即用协议（plug-and-play protocol），**特别适用于主机频繁加入和离开网络的环境

**网络地址转换**

![WeChat Screenshot_20190706233446](/assets/img/resource/computer-network/ip-address-transform.png)

![WeChat Screenshot_20190706233505](/assets/img/resource/computer-network/WeChat-Screenshot_20190706233505.png)

![WeChat Screenshot_20190706233514](/assets/img/resource/computer-network/ip-address-transform3.png)

**IPv6编址**

IPv6的数据报文

![ipv6-post](/assets/img/resource/computer-network/ipv6-post.png)

- 扩大的地址容量： 地址长度从32比特增加到128比特，128比特够地球上的每个沙粒都分配一个IP地址，除了**多播地址（点对子集）**和**单播地址(点对点)**以外，IPv6新增**任播地址**（anycast address）使得数据报交付给一组主机中的任何一个
- 简化高效的40字节首部
- 流标签和优先级，给特殊的流打上标签，这些特殊流可能是发送方要求特殊处理的

### 因特网控制报文协议（ICMP）

ICMP其实在体系结构上是位于IP之上的，ICMP报文作为IP有效载荷承载的，就像TCP和UDP报文段作为有效承载一样，主机接收到IP报文，会把分解出的数据报的内容交给ICMP，如果收一个指明上层协议是ICMP的话，就和分解数据报交给UDP,ICP一样。当发生主机不可达，或者其他不可达情况，ICMP协议负责把情况封包，传送回主机

![WeChat Screenshot_20190707001105](/assets/img/resource/computer-network/icmp.png)

### 路由选择算法（单播）

路由选择的工作是：确定从发送方到接收方通过路由器网络的好路径，通常一条好路径是指的是cost低的路径

主机与一台路由器相连接，该路由器称为**默认路由器（default router），或者第一跳路由器（first-hop router），路径选择就是在源默认路由器到目的默认路由器的问题。**一条路径的链路的cost由物理长度，链路速度，链路相关金融上的费用，还要考虑策略因素。路由选择算法用图论来描述的话，就是**最短路径问题。**

常用路径算法有两类：

- 全局式路由选择算法：完整的，全局性的计算，提前需要所有节点之间的连通性以及费用。
- 迭代分布式的计算，没有节点知道关于所有链路费用的完整信息，只有相邻节点的费用知识。（Bellman-Ford）

也可分为：

- 静态路由选择算法，路由变化缓慢，通常是人为干预
- 动态路由选择算法，根据负载或拓扑变化改变路由选择路径

或者：

- 负载敏感，链路费用动态反应链路的拥塞程度
- 负载迟钝

### 广播路由选择算法

源节点产生分组的N分副本，并用单播路由选择向N个目的地传输N分副本称为**N次单播**，这样效率很低，多个副本可能通过同一链路传播，不如让中间路由节点在需要的时候才产生副本，而不是一开始就产生然后传输很多遍，由于N次单播的种种缺点，让网络参与分组复制，转发就很自然的想到

- 无控制洪泛（flooding）
- 受控洪泛
- 生成树广播
- 实践中的广播算法

### **多播路由选择**

使用**间接寻址（address indirection）,** 用一个标志来表示一组接受方，寻址到该组的分组副本被交付给所有与该组相关联的多播接收方。一组接受方的单一表示就是一个D类多播地址，于D类地址相关联的接收方小组称为一个多播组（multicast group）



# 链路层

任一链路层的基本服务都是将数据报通过单一通信链路从一个结点移动到相邻结点，链路层**可能提供的服务**

- 成帧（framing）把网络层数据报用链路层帧封装起来
- 链路接入。媒体访问控制（Medium Access Control, MAC）协议规定了帧在连路上传输的规则
- 可靠服务差错检测和纠正

**链路层是实现在路由器的线路卡中的，在主机中是在网络适配器（network adapter ）中的链路层控制器芯片中实现的**

 

### 多路访问链路和协议

点对点链路：单一发送方和接受方

广播链路：多个发送方，多个接收方都连接到相同的，单一的，共享的广播信道上（例如wifi链路）

如何协调这多个发送方和接收方，发送方和接收方还可以互换，在单一，共享信道上的通信是**多路访问问题（multiple access problem），** 解决这个问题就有**多路访问协议，**分为三个大类：

- **信道划分协议**，时分复用（round-robin形式）和频分复用
- **随机接入协议**，一个传输节点总是以信道的全部速率进行发送的；当节点有一个新帧要发送时，等到下一个时隙，并在时隙传输整个帧；如果没有碰撞，成功传输，不考虑重新传送该帧，如果碰撞，在时隙结束前检测碰撞，该节点以重传概率p在后续时隙重传该帧，直到无碰撞的传输出去。
- **轮流协议，轮询协议**确定主节点，然后主节点以循环的方式轮询每个结点，告诉每个结点它能传输的帧的最大数量；**令牌传递协议，**token按照固定次序进行交换，拿到令牌的结点传输最大帧数，然后释放令牌到下一个结点

主机和路由器不光具有网络层地址IP，还具有**链路层地址**，具体点是他们的适配器具有链路层地址，链路层地址称为LAN地址，物理地址或**MAC地址**，MAC地址具有6字节大小，采用16进制表示法（88-B2-2F-54-1A-0F）和IP不同的是，MAC地址是扁平结构，不是具有层次的。无论适配器到哪里都不会变化，IP地址随之物理地址变化，一般是会变化的。

因为存在网路层地址和链路层地址，需要在它们之间进行转换，由**地址解析协议（address resolution protocol）提供**

 

![WeChat Screenshot_20190707164919](/assets/img/resource/computer-network/WeChat-Screenshot_20190707164919.png)

![WeChat Screenshot_20190707164930](/assets/img/resource/computer-network/WeChat-Screenshot_20190707164930.png)

首先考虑在局域网中传送数据报的情况，图5-17 主机C发送数据报到主机A，主机C要向网络适配器不仅提供IP数据还要提供A的MAC地址，链路层把网络层数据报IP封装，**构造一个包含目的地MAC地址的链路层帧。**主机C怎么知道主机A的MAC地址呢，就通过ARP协议，提供相同局域网上任何IP地址作为输入，返回相应的MAC地址，类似DNS提供的服务，每台主机或路由器在其内存中具有一个ARP table，类似key-value pair

如果主机要查询的IP没有在ARP的ARP table内呢？

首先发送方构造一个ARP分组（ARP packet）的特殊分组发送给适配器，指示适配器用MAC广播地址（FF-FF-FF-FF-FF-FF）,能被子网中所有适配器接收到，适配器上传ARP分组到ARP模块，ARP查询IP地址和是否和目的IP一致，匹配到的适配器发回一个响应ARP分组，源主机更新其ARP table

那万一主机向子网之外发送数据报呢？，如图5-19，适配器首先向默认路由器发送一个链路帧，其中的网络层IP地址就是目的主机IP，此时的MAC地址不是目的主机适配器的MAC地址而是默认路由器的MAC地址，由于默认路由器是在子网内的，所以可以通过ARP得到MAC地址，所以链路层帧下一步传送到那个适配器，链路层帧的目标MAC地址就是下一个适配器的MAC地址。

### **交换机和路由器的比较**

路由器是使用网络层地址转发分组的存储转发分组的存储转发分组交换机，交换机也是存储转发分组交换机。可是交换机**是使用MAC地址来转发分组**，交换机是第二层的分组交换机，路由器是第三层的分组交换机，意思就是路由器实现了物理层，链路层和网络层，交换机没有实现网络层协议，所以只能使用链路层地址来寻址。

交换机

- 即插即用
- 具有相对高的分组过滤和转发速率
- 可观的ARP流量和处理量
- 对广播风暴没有保护措施

路由器

- 因为路由器网络寻址是分层次的，分组通常不会通过路由器循环，路由器可以使用丰富的拓扑结构构建因特网
- 对第二层的广播风暴提供了防火墙保护
- 不能即插即用
- 对分组的处理时间比交换机长，因为实现了3层协议